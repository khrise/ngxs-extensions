{"version":3,"sources":["../../../src/lib/core/internal/injector-accessor.service.ts","../../../src/lib/decorators.module.ts","../../../src/lib/core/internal/utils.ts","../../../src/lib/core/decorators/reset-state.decorator.ts"],"names":["InjectorAccessorService","injector","getInjector","this","Error","i0","ɵɵinject","Injector","ɵprov","ɵɵdefineInjectable","token","factory","ɵfac","NgxsExtensionsDecoratorsModule","injectorAccessorService","forRoot","ngModule","providers","i1.InjectorAccessorService","idCounter","stateClass","target","key","descriptor","id","prefix","uniqueId","fn","type","name","meta","ensureStoreMetadata","actions","hasOwnProperty","prototype","_a","setState","defaults","options","original","value","dispatch","get","Store","args","_i","arguments","length","result","apply","Observable","toPromise","then","Promise"],"mappings":"ywBAGAA,EAAA,WAGE,SAAAA,EAAYC,GACVD,EAAwBC,SAAWA,SAGvBD,EAAAE,YAAP,WACL,GAAsB,OAAlBC,KAAKF,SACP,MAAM,IAAIG,MAAM,qDAGlB,OAAOD,KAAKF,YAZhB,GACiBD,EAAQC,SAAoB,sCADhCD,GAAuBK,EAAAC,SAAAD,EAAAE,YAAvBP,EAAAQ,MAAAH,EAAAI,mBAAA,CAAAC,MAAAV,EAAuBW,QAAvBX,EAAuBY,OCCpC,IAAAC,EAAA,WACE,SAAAA,EAA4BC,GAAAX,KAAuBW,wBAAvBA,SAEdD,EAAAE,QAAP,WACL,MAAO,CACLC,SAAUH,EACVI,UAAW,CAACjB,OANlB,mCAAaa,iEAAAA,GAA8BR,EAAAC,SAAAY,EAAA,OCH3C,IAAMC,EAAY,4DCUZ,SAA8BC,GAClC,OAAO,SAASC,EAAaC,EAAaC,GAExC,IAAMC,EDEJ,SAAmBC,QAAA,IAAAA,IAAAA,EAAgB,SAClCN,EAAUM,KACbN,EAAUM,GAAU,GAGtB,IAAMD,IAAOL,EAAUM,GACvB,MAAe,UAAXA,EACK,GAAGD,EAGL,IAAGC,EAASD,GCZNE,GACLC,EAAK,cAAcH,EACnBI,EAAO,IAAIR,EAAWS,KAAI,iBAAiBL,EAC3CM,EAAOC,EAAAA,oBAAoBX,GAEjC,GAAIU,EAAKE,QAAQC,eAAeL,GAC9B,MAAM,IAAIxB,MAAM,oCAAqCwB,EAAI,oBAI3DR,EAAWc,UAAUP,GAAM,SAACQ,IAC1BC,EADoCD,EAAAC,UAC3BN,EAAKO,WAIhBP,EAAKE,QAAQJ,GAAQ,CACnB,CACED,GAAEA,EACFW,QAAS,GACTV,KAAIA,IAKR,IAAMW,EAAqBhB,EAAWiB,MACtC,SAASC,IACPzC,EAAwBE,cACrBwC,IAAWC,EAAAA,OACXF,SAAS,CAAEb,KAAIA,IAoBpB,OAHAL,EAAWiB,MAfX,eAA4B,IAAcI,EAAA,GAAAC,EAAA,EAAdA,EAAcC,UAAAC,OAAdF,IAAAD,EAAcC,GAAAC,UAAAD,GACxC,IAAMG,EAAST,EAASU,MAAM9C,KAAMyC,GAEpC,OAAII,aAAkBE,EAAAA,YACpBF,EAAOG,YAAYC,KAAKX,GACjBO,GAGLA,aAAkBK,QACbL,EAAOI,KAAKX,IAGrBA,IACOO,IAKFzB","sourcesContent":["import { Injectable, Injector } from '@angular/core';\r\n\r\n@Injectable()\r\nexport class InjectorAccessorService {\r\n  private static injector: Injector | null = null;\r\n\r\n  constructor(injector: Injector) {\r\n    InjectorAccessorService.injector = injector;\r\n  }\r\n\r\n  public static getInjector(): never | Injector {\r\n    if (this.injector === null) {\r\n      throw new Error('\"NgxsExtensionsDecoratorsModule\" is not imported.');\r\n    }\r\n\r\n    return this.injector;\r\n  }\r\n}\r\n","import { ModuleWithProviders, NgModule, Self } from '@angular/core';\r\nimport { InjectorAccessorService } from './core/internal/injector-accessor.service';\r\n\r\n@NgModule()\r\nexport class NgxsExtensionsDecoratorsModule {\r\n  constructor(@Self() private injectorAccessorService: InjectorAccessorService) {}\r\n\r\n  public static forRoot(): ModuleWithProviders<NgxsExtensionsDecoratorsModule> {\r\n    return {\r\n      ngModule: NgxsExtensionsDecoratorsModule,\r\n      providers: [InjectorAccessorService],\r\n    };\r\n  }\r\n}\r\n","/** Used to generate unique IDs. */\r\nconst idCounter = {};\r\n\r\n/**\r\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\r\n *\r\n * @param prefix The value to prefix the ID with.\r\n * @returns Returns the unique ID.\r\n * @example\r\n *\r\n * uniqueId('contact_')\r\n * // => 'contact_104'\r\n *\r\n * uniqueId()\r\n * // => '105'\r\n */\r\nexport function uniqueId(prefix = '$ids$'): string {\r\n  if (!idCounter[prefix]) {\r\n    idCounter[prefix] = 0;\r\n  }\r\n\r\n  const id = ++idCounter[prefix];\r\n  if (prefix === '$ids$') {\r\n    return `${id}`;\r\n  }\r\n\r\n  return `${prefix + id}`;\r\n}\r\n","import { ensureStoreMetadata, StateContext, Store } from '@ngxs/store';\r\nimport { Observable } from 'rxjs';\r\nimport { tap } from 'rxjs/operators';\r\nimport { InjectorAccessorService } from '../internal/injector-accessor.service';\r\nimport { uniqueId } from '../internal/utils';\r\n\r\n/**\r\n * Decorator to reset state to default on method call.\r\n *\r\n * @param stateClass state to get defaults from\r\n */\r\nexport function ResetStateToDefault(stateClass: any) {\r\n  return function(target: any, key: string, descriptor: TypedPropertyDescriptor<any>) {\r\n    // create meta data\r\n    const id = uniqueId();\r\n    const fn = `resetAction${id}`;\r\n    const type = `[${stateClass.name}] ResetAction-${id}`;\r\n    const meta = ensureStoreMetadata(stateClass);\r\n\r\n    if (meta.actions.hasOwnProperty(type)) {\r\n      throw new Error(`Method decorated with such type \\`${type}\\` already exists`);\r\n    }\r\n\r\n    // set action handler on state class\r\n    stateClass.prototype[fn] = ({ setState }: StateContext<any>) => {\r\n      setState(meta.defaults);\r\n    };\r\n\r\n    // set meta data\r\n    meta.actions[type] = [\r\n      {\r\n        fn,\r\n        options: {},\r\n        type,\r\n      },\r\n    ];\r\n\r\n    // wrap original function to call dispatch after method has finished\r\n    const original: Function = descriptor.value;\r\n    function dispatch() {\r\n      InjectorAccessorService.getInjector()\r\n        .get<Store>(Store)\r\n        .dispatch({ type });\r\n    }\r\n    function wrapper(this: any, ...args: any[]) {\r\n      const result = original.apply(this, args);\r\n      // handle observable\r\n      if (result instanceof Observable) {\r\n        result.toPromise().then(dispatch);\r\n        return result;\r\n      }\r\n      // handle promise\r\n      if (result instanceof Promise) {\r\n        return result.then(dispatch);\r\n      }\r\n      // handle sync call\r\n      dispatch();\r\n      return result;\r\n    }\r\n    descriptor.value = wrapper;\r\n\r\n    // return descriptor\r\n    return descriptor;\r\n  };\r\n}\r\n"]}